import Head from "next/head";
import ddPeriod from "../data/ddperiod.json";
import returns from "../data/returns.json";
import { useEffect, useMemo, useRef } from "react";
import { ColorType, createChart } from "lightweight-charts";
import { isAfter, eachDayOfInterval, format, differenceInDays } from "date-fns";
import {
  Box,
  Grid,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
} from "@mui/material";

export default function Home() {
  const chartContainerRef = useRef<HTMLDivElement>(null);

  const datedMap = useMemo(() => {
    const valueMap = new Map<string, number>();
    returns.data.combined.forEach((value) => {
      valueMap.set(value.date, value.cumsum);
    });
    return valueMap;
  }, []);

  const sortedIntervals = useMemo(() => {
    const intervals = ddPeriod.data.toSorted((a, b) => {
      const dateA = new Date(a.Start_Date).getTime();
      const dateB = new Date(b.Start_Date).getTime();
      return dateA - dateB;
    });

    const mergedIntervals = [];

    mergedIntervals.push(intervals[0]);
    let maxEndDate = mergedIntervals[0].End_Date;
    for (let i = 1; i < intervals.length; i++) {
      if (isAfter(intervals[i].Start_Date, maxEndDate)) {
        mergedIntervals.push(intervals[i]);
        maxEndDate = intervals[i].End_Date;
      } else if (isAfter(intervals[i].End_Date, maxEndDate)) {
        mergedIntervals[mergedIntervals.length - 1].End_Date =
          intervals[i].End_Date;
        maxEndDate = intervals[i].End_Date;
      }
    }
    return mergedIntervals.map((period) => {
      return eachDayOfInterval({
        start: period.Start_Date,
        end: period.End_Date,
      }).reduce<{ time: string; value: number }[]>((prev, date) => {
        const key = format(date, "yyyy-MM-dd");
        if (datedMap.has(key)) {
          prev.push({ time: key, value: datedMap.get(key)! });
        }
        return prev;
      }, []);
    });
  }, [datedMap]);

  useEffect(() => {
    if (chartContainerRef.current) {
      const chart = createChart(chartContainerRef.current, {
        layout: {
          background: { type: ColorType.Solid },
          textColor: "#000",
        },
        width: chartContainerRef.current.clientWidth,
        height: 300,
        leftPriceScale: {
          visible: true,
          ticksVisible: true,
        },
        rightPriceScale: {
          visible: false,
        },
      });

      chart.timeScale().fitContent();

      const newSeries = chart.addLineSeries({
        color: "gray",
      });
      newSeries.setData(
        returns.data.combined.map((data) => ({
          time: data.date,
          value: data.cumsum,
        }))
      );

      sortedIntervals.forEach((intervals) => {
        const highlightSeries = chart.addAreaSeries({
          lastValueVisible: false,
          lineColor: "red",
          topColor: "#ff000090",
          bottomColor: "#ffffff01",
        });

        highlightSeries.setData(intervals);
      });

      return () => {
        chart.remove();
      };
    }
  }, [sortedIntervals]);

  return (
    <>
      <Head>
        <title>Matic Algos</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <div
        style={{ flexDirection: "row", display: "flex", position: "relative" }}
      >
        <div
          ref={chartContainerRef}
          style={{ maxWidth: "80%", height: "100%", width: "100% " }}
        />
        <TableContainer>
          <Table sx={{borderRadius: 4, border:"solid", overflow: "clip"}}>
            <TableHead sx={{bgcolor: "#f2f2f2"}}>
              <TableRow>
                <TableCell>Period</TableCell>
                <TableCell>Max DD</TableCell>
                <TableCell>Days</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {ddPeriod.data.map((dd) => (
                <TableRow key={`${dd.Start_Date}-${dd.End_Date}`}>
                  <TableCell>{`${dd.Start_Date} ${dd.End_Date}`}</TableCell>
                  <TableCell>{dd.Max_Drawdown.toFixed(2)}</TableCell>
                  <TableCell>
                    {differenceInDays(dd.End_Date, dd.Start_Date)}
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      </div>
    </>
  );
}
